using Veldrid;
using System;
using static Prowl.Runtime.TextureUtility;

namespace Prowl.Runtime
{
    /// <summary>
    /// This is the base class for all texture types and manages some of their internal workings.
    /// </summary>
    /// <remarks>
    /// Much of this class is comprised of validations and utilities to make working with a <see cref="Veldrid.Texture"/> safer.
    /// </remarks>
    public abstract class Texture : EngineObject
    {
        /// <summary>The handle for the GL Texture Object.</summary>
        public Veldrid.Texture InternalTexture { get; protected set; }

        /// <summary>The type of this <see cref="Texture"/>, such as 1D, 2D, 3D.</summary>
        public TextureType Type => InternalTexture.Type;

        /// <summary>The format of this <see cref="Texture"/>.</summary>
        public PixelFormat Format => InternalTexture.Format;

        /// <summary>The use cases this <see cref="Texture"/> is prepared for.</summary>
        public TextureUsage Usage => InternalTexture.Usage;

        /// <summary>The mip levels of this <see cref="Texture"/>.</summary>
        public uint MipLevels => InternalTexture.MipLevels;

        /// <summary>Gets whether this <see cref="Texture"/> has mipmaps generated by calling <see cref="GenerateMipmaps"/> .</summary>
        /// <remarks>This field is disabled if a texture is recreated. Manually setting a mip level will not set this field.</remarks>
        public bool IsMipmapped { get; protected set; }

        /// <summary>Gets whether this <see cref="Texture"/> can be automatically mipmapped (depends on texture type).</summary>
        public bool IsMipmappable => InternalTexture.Usage.HasFlag(TextureUsage.GenerateMipmaps);

        private Veldrid.Texture stagingTexture = null;



        internal Texture() : base("New Texture") { }


        internal Texture(TextureDescription description) : base("New Texture")
        {
            RecreateInternalTexture(description);
        }


        protected void RecreateInternalTexture(TextureDescription description)
        {
            InternalTexture?.Dispose();

            if (!IsSupportedDescription(description, out _, out Exception exception))
                throw exception;

            InternalTexture = Graphics.Device.ResourceFactory.CreateTexture(ref description);
            IsMipmapped = false;
        }


        public override void OnDispose()
        {
            InternalTexture.Dispose();

            stagingTexture?.Dispose();
        }


        public void GenerateMipmaps()
        {
            if (!IsMipmappable)
                throw new InvalidOperationException($"Cannot generate mipmaps on a non-mipmappable texture. Ensure texture is created with the {TextureUsage.GenerateMipmaps} flag.");

            CommandList commandList = Graphics.Device.ResourceFactory.CreateCommandList();

            commandList.GenerateMipmaps(InternalTexture);

            Graphics.Device.SubmitCommands(commandList);

            IsMipmapped = true;
        }


        /// <summary>
        /// Gets the estimated memory usage in bytes of the <see cref="Texture"/>.
        /// </summary>
        public uint GetMemoryUsage()
        {
            return InternalTexture.Width * InternalTexture.Height * InternalTexture.Depth * InternalTexture.ArrayLayers * PixelFormatBytes(Format);
        }


        // Ensure that a CPU-accessible staging texture matching the internal one exists   
        private void EnsureStagingTexture()
        {
            if (InternalTexture.Usage.HasFlag(TextureUsage.Staging))
            {
                stagingTexture = InternalTexture;
                return;
            }

            if (stagingTexture != null &&
                stagingTexture.Width == InternalTexture.Width &&
                stagingTexture.Height == InternalTexture.Height &&
                stagingTexture.Depth == InternalTexture.Depth &&
                stagingTexture.ArrayLayers == InternalTexture.ArrayLayers &&
                stagingTexture.Type == InternalTexture.Type &&
                stagingTexture.MipLevels == InternalTexture.MipLevels &&
                stagingTexture.Format == InternalTexture.Format)
                return;

            TextureDescription description = new()
            {
                Width = InternalTexture.Width,
                Height = InternalTexture.Height,
                Depth = InternalTexture.Depth,
                ArrayLayers = InternalTexture.ArrayLayers,
                Type = Type,
                MipLevels = MipLevels,
                Usage = TextureUsage.Staging,
                Format = Format,
                SampleCount = TextureSampleCount.Count1,
            };

            stagingTexture = Graphics.Device.ResourceFactory.CreateTexture(ref description);

            return;
        }


        unsafe protected void InternalSetDataPtr(void* data, Vector3Int rectPos, Vector3Int rectSize, uint layer, uint mipLevel)
        {
            ValidateRectOperation(rectPos, rectSize, layer, mipLevel);

            uint mipWidth = GetMipDimension(InternalTexture.Width, mipLevel);
            uint mipHeight = GetMipDimension(InternalTexture.Height, mipLevel);
            uint mipDepth = GetMipDimension(InternalTexture.Depth, mipLevel);

            uint mipLevelSize = mipWidth * mipHeight * mipDepth * PixelFormatBytes(Format);

            EnsureStagingTexture();
            Graphics.Device.UpdateTexture(stagingTexture, (IntPtr)data, mipLevelSize, (uint)rectPos.x, (uint)rectPos.y, (uint)rectPos.z, (uint)rectSize.x, (uint)rectSize.y, (uint)rectSize.z, mipLevel, layer);

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(stagingTexture, InternalTexture, mipLevel, layer, true);
        }


        unsafe protected void InternalSetData<T>(Memory<T> data, Vector3Int rectPos, Vector3Int rectSize, uint layer, uint mipLevel) where T : unmanaged
        {
            if (data.Length * sizeof(T) < rectSize.x * rectSize.y * rectSize.z)
                throw new ArgumentException("Not enough pixel data", nameof(data));

            fixed (void* ptr = data.Span)
                InternalSetDataPtr(ptr, rectPos, rectSize, layer, mipLevel);
        }


        unsafe protected void InternalCopyDataPtr(void* dataPtr, out uint rowPitch, out uint depthPitch, uint arrayLayer, uint mipLevel)
        {
            EnsureStagingTexture();

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(InternalTexture, stagingTexture, mipLevel, arrayLayer, true);

            uint subresource = (MipLevels * arrayLayer) + mipLevel;

            MappedResource resource = Graphics.Device.Map(stagingTexture, MapMode.Read, subresource);

            rowPitch = resource.RowPitch;
            depthPitch = resource.DepthPitch;

            Buffer.MemoryCopy((void*)resource.Data, dataPtr, resource.SizeInBytes, resource.SizeInBytes);

            Graphics.Device.Unmap(stagingTexture, subresource);
        }


        unsafe protected void InternalCopyData<T>(Memory<T> data, uint arrayLayer, uint mipLevel) where T : unmanaged
        {
            EnsureStagingTexture();

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(InternalTexture, stagingTexture, mipLevel, arrayLayer, true);

            uint subresource = (MipLevels * arrayLayer) + mipLevel;

            MappedResource resource = Graphics.Device.Map(stagingTexture, MapMode.Read, subresource);

            if (data.Length * sizeof(T) < resource.SizeInBytes)
                throw new ArgumentException("Insufficient space to store the requested pixel data", nameof(data));

            fixed (void* ptr = data.Span)
                Buffer.MemoryCopy((void*)resource.Data, ptr, data.Length * sizeof(T), resource.SizeInBytes);

            Graphics.Device.Unmap(stagingTexture, subresource);
        }


        private void ValidateRectOperation(Vector3Int rect, Vector3Int size, uint layer, uint mipLevel)
        {
            if (rect.x < 0 || rect.x >= InternalTexture.Width)
                throw new ArgumentOutOfRangeException("Rect X", rect.x, "Rect X must be in the range [0, " + InternalTexture.Width + "]");

            if (rect.y < 0 || rect.y >= InternalTexture.Height)
                throw new ArgumentOutOfRangeException("Rect Y", rect.y, "Rect Y must be in the range [0, " + InternalTexture.Height + "]");

            if (rect.z < 0 || rect.z >= InternalTexture.Depth)
                throw new ArgumentOutOfRangeException("Rect Z", rect.z, "Rect Z must be in the range [0, " + InternalTexture.Depth + "]");

            if (size.x <= 0)
                throw new ArgumentOutOfRangeException("Rect Width", size.x, "Rect width must be greater than 0");

            if (size.y <= 0)
                throw new ArgumentOutOfRangeException("Rect Height", size.y, "Rect height must be greater than 0");

            if (size.z <= 0)
                throw new ArgumentOutOfRangeException("Rect Depth", size.z, "Rect depth must be greater than 0");

            if (size.x > InternalTexture.Width - rect.x || size.y > InternalTexture.Height - rect.y || size.z > InternalTexture.Depth - rect.z)
                throw new ArgumentOutOfRangeException("Specified area is outside of the texture's storage");

            if (layer >= InternalTexture.ArrayLayers)
                throw new ArgumentOutOfRangeException("Layer", layer, "Array layer must be in the range [0, " + InternalTexture.ArrayLayers + "]");

            if (mipLevel >= InternalTexture.MipLevels)
                throw new ArgumentOutOfRangeException("Mip level", mipLevel, "Mip level must be in the range [0, " + InternalTexture.MipLevels + "]");
        }
    }
}
