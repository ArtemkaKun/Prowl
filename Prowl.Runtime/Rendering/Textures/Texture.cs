using Veldrid;
using System;
using static Prowl.Runtime.TextureUtility;

namespace Prowl.Runtime
{
    /// <summary>
    /// This is the base class for all texture types and manages some of their internal workings.
    /// </summary>
    /// <remarks>
    /// Much of this class is comprised of validations and utilities to make working with a <see cref="Veldrid.Texture"/> safer.
    /// </remarks>
    public abstract class Texture : EngineObject, ISerializable
    {
        /// <summary>The type of this <see cref="Texture"/>, such as 1D, 2D, 3D.</summary>
        public TextureType Type => InternalTexture.Type;

        /// <summary>The format of this <see cref="Texture"/>.</summary>
        public PixelFormat Format => InternalTexture.Format;

        /// <summary>The use cases this <see cref="Texture"/> is prepared for.</summary>
        public TextureUsage Usage => InternalTexture.Usage;

        /// <summary>The mip levels of this <see cref="Texture"/>.</summary>
        public uint MipLevels => InternalTexture.MipLevels;

        /// <summary>Gets whether this <see cref="Texture"/> has mipmaps generated by calling <see cref="GenerateMipmaps"/> .</summary>
        /// <remarks>This field is disabled if a texture is recreated. Manually setting a mip level will not set this field.</remarks>
        public bool IsMipmapped { get; protected set; }

        /// <summary>Gets whether this <see cref="Texture"/> can be automatically mipmapped.</summary>
        public bool IsMipmappable => Usage.HasFlag(TextureUsage.GenerateMipmaps);

        /// <summary>The sampler for this <see cref="Veldrid.Texture"/></summary>
        public TextureSampler Sampler { get; private set; } = TextureSampler.Linear;


        /// <summary>The internal <see cref="Veldrid.Texture"/> representation.</summary>
        internal Veldrid.Texture InternalTexture { get; private set; }

        /// <inheritdoc cref="Veldrid.TextureView"/>
        internal Veldrid.TextureView TextureView { get; private set; } 


        private Veldrid.Texture stagingTexture = null;

        

        internal Texture() : base("New Texture") { }

        internal Texture(TextureDescription description) : base("New Texture") 
        { 
            RecreateInternalTexture(description);
        }

        public override void OnDispose()
        {
            InternalTexture?.Dispose();
            TextureView?.Dispose();
            stagingTexture?.Dispose();

            InternalTexture = null;
            TextureView = null;
            stagingTexture = null;

            DestroyImmediate(Sampler);
        }

        public void GenerateMipmaps(bool waitForCompletion = false)
        {
            if (!IsMipmappable)
                throw new InvalidOperationException($"Cannot generate mipmaps on a non-mipmappable texture. Ensure texture is created with the {TextureUsage.GenerateMipmaps} flag.");

            Fence fence = Graphics.ResourceFactory.CreateFence(false);
            CommandList commandList = Graphics.ResourceFactory.CreateCommandList();

            commandList.GenerateMipmaps(InternalTexture);

            Graphics.Device.SubmitCommands(commandList, fence);

            if (waitForCompletion)
                Graphics.Device.WaitForFence(fence);
            fence.Dispose();

            IsMipmapped = true;
        }

        /// <summary>
        /// Gets the estimated memory usage in bytes of the <see cref="Texture"/>.
        /// </summary>
        public uint GetMemoryUsage()
        {
            return InternalTexture.Width * InternalTexture.Height * InternalTexture.Depth * InternalTexture.ArrayLayers * PixelFormatBytes(Format);
        }

        protected void RecreateInternalTexture(TextureDescription description)
        {
            OnDispose();

            // None of these values should ever be zero, so make sure they're all clamped to a minimum of 1.
            description.Width = Math.Max(1, description.Width);
            description.Height = Math.Max(1, description.Height);
            description.Depth = Math.Max(1, description.Depth);
            description.ArrayLayers = Math.Max(1, description.ArrayLayers);
            description.MipLevels = Math.Max(1, description.MipLevels);
            description.SampleCount = TextureSampleCount.Count1;

            if (!IsSupportedDescription(description, out _, out Exception exception))
                throw exception;

            InternalTexture = Graphics.ResourceFactory.CreateTexture(ref description);

            TextureViewDescription viewDescription = new()
            {
                ArrayLayers = description.ArrayLayers,
                BaseArrayLayer = 0,
                MipLevels = description.MipLevels,
                BaseMipLevel = 0,
                Format = description.Format,
                Target = InternalTexture
            };

            TextureView = Graphics.ResourceFactory.CreateTextureView(ref viewDescription);

            IsMipmapped = false;
        }

        unsafe protected void InternalSetDataPtr(void* data, Vector3Int rectPos, Vector3Int rectSize, uint layer, uint mipLevel)
        {
            ValidateRectOperation(rectPos, rectSize, layer, mipLevel);

            uint mipWidth = GetMipDimension(InternalTexture.Width, mipLevel);
            uint mipHeight = GetMipDimension(InternalTexture.Height, mipLevel);
            uint mipDepth = GetMipDimension(InternalTexture.Depth, mipLevel);

            uint mipLevelSize = mipWidth * mipHeight * mipDepth * PixelFormatBytes(Format);

            EnsureStagingTexture();
            Graphics.Device.UpdateTexture(stagingTexture, (IntPtr)data, mipLevelSize, (uint)rectPos.x, (uint)rectPos.y, (uint)rectPos.z, (uint)rectSize.x, (uint)rectSize.y, (uint)rectSize.z, mipLevel, layer);

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(stagingTexture, InternalTexture, mipLevel, layer, true);
        }

        unsafe protected void InternalSetData<T>(Memory<T> data, Vector3Int rectPos, Vector3Int rectSize, uint layer, uint mipLevel) where T : unmanaged
        {
            if (data.Length * sizeof(T) < rectSize.x * rectSize.y * rectSize.z)
                throw new ArgumentException("Not enough pixel data", nameof(data));

            fixed (void* ptr = data.Span)
                InternalSetDataPtr(ptr, rectPos, rectSize, layer, mipLevel);
        }

        unsafe protected void InternalCopyDataPtr(void* dataPtr, out uint rowPitch, out uint depthPitch, uint arrayLayer, uint mipLevel)
        {
            EnsureStagingTexture();

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(InternalTexture, stagingTexture, mipLevel, arrayLayer, true);

            uint subresource = (MipLevels * arrayLayer) + mipLevel;

            MappedResource resource = Graphics.Device.Map(stagingTexture, MapMode.Read, subresource);

            rowPitch = resource.RowPitch;
            depthPitch = resource.DepthPitch;

            Buffer.MemoryCopy((void*)resource.Data, dataPtr, resource.SizeInBytes, resource.SizeInBytes);

            Graphics.Device.Unmap(stagingTexture, subresource);
        }

        unsafe protected void InternalCopyData<T>(Memory<T> data, uint arrayLayer, uint mipLevel) where T : unmanaged
        {
            EnsureStagingTexture();

            if (stagingTexture != InternalTexture)
                Graphics.InternalCopyTexture(InternalTexture, stagingTexture, mipLevel, arrayLayer, true);

            uint subresource = (MipLevels * arrayLayer) + mipLevel;

            MappedResource resource = Graphics.Device.Map(stagingTexture, MapMode.Read, subresource);

            if (data.Length * sizeof(T) < resource.SizeInBytes)
                throw new ArgumentException("Insufficient space to store the requested pixel data", nameof(data));

            fixed (void* ptr = data.Span)
                Buffer.MemoryCopy((void*)resource.Data, ptr, data.Length * sizeof(T), resource.SizeInBytes);

            Graphics.Device.Unmap(stagingTexture, subresource);
        }

        // Ensure that a CPU-accessible staging texture matching the internal one exists   
        // If the internal texture is already a staging texture, uses itself.
        private void EnsureStagingTexture()
        {
            if (InternalTexture.Usage.HasFlag(TextureUsage.Staging))
            {
                stagingTexture = InternalTexture;
                return;
            }

            if (stagingTexture != null &&
                stagingTexture.Width == InternalTexture.Width &&
                stagingTexture.Height == InternalTexture.Height &&
                stagingTexture.Depth == InternalTexture.Depth &&
                stagingTexture.ArrayLayers == InternalTexture.ArrayLayers &&
                stagingTexture.Type == InternalTexture.Type &&
                stagingTexture.MipLevels == InternalTexture.MipLevels &&
                stagingTexture.Format == InternalTexture.Format)
                return;

            TextureDescription description = new()
            {
                Width = InternalTexture.Width,
                Height = InternalTexture.Height,
                Depth = InternalTexture.Depth,
                ArrayLayers = InternalTexture.ArrayLayers,
                Type = Type,
                MipLevels = MipLevels,
                Usage = TextureUsage.Staging,
                Format = Format,
                SampleCount = TextureSampleCount.Count1,
            };

            stagingTexture = Graphics.Device.ResourceFactory.CreateTexture(ref description);

            return;
        }

        private void ValidateRectOperation(Vector3Int rect, Vector3Int size, uint layer, uint mipLevel)
        {
            if (rect.x < 0 || rect.x >= InternalTexture.Width)
                throw new ArgumentOutOfRangeException("Rect X", rect.x, "Rect X must be in the range [0, " + InternalTexture.Width + "]");

            if (rect.y < 0 || rect.y >= InternalTexture.Height)
                throw new ArgumentOutOfRangeException("Rect Y", rect.y, "Rect Y must be in the range [0, " + InternalTexture.Height + "]");

            if (rect.z < 0 || rect.z >= InternalTexture.Depth)
                throw new ArgumentOutOfRangeException("Rect Z", rect.z, "Rect Z must be in the range [0, " + InternalTexture.Depth + "]");

            if (size.x <= 0)
                throw new ArgumentOutOfRangeException("Rect Width", size.x, "Rect width must be greater than 0");

            if (size.y <= 0)
                throw new ArgumentOutOfRangeException("Rect Height", size.y, "Rect height must be greater than 0");

            if (size.z <= 0)
                throw new ArgumentOutOfRangeException("Rect Depth", size.z, "Rect depth must be greater than 0");

            if (size.x > InternalTexture.Width - rect.x || size.y > InternalTexture.Height - rect.y || size.z > InternalTexture.Depth - rect.z)
                throw new ArgumentOutOfRangeException("Specified area is outside of the texture's storage");

            if (layer >= InternalTexture.ArrayLayers)
                throw new ArgumentOutOfRangeException("Layer", layer, "Array layer must be in the range [0, " + InternalTexture.ArrayLayers + "]");

            if (mipLevel >= InternalTexture.MipLevels)
                throw new ArgumentOutOfRangeException("Mip level", mipLevel, "Mip level must be in the range [0, " + InternalTexture.MipLevels + "]");
        }


        public abstract SerializedProperty Serialize(Serializer.SerializationContext ctx);

        public abstract void Deserialize(SerializedProperty value, Serializer.SerializationContext ctx);
    }
}
